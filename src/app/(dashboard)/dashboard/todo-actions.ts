'use server'

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'

// ========================================================
// Type Definitions
// ========================================================

export type Todo = {
    id: string
    user_id: string
    text: string
    completed: boolean
    is_auto_generated: boolean
    source_type: string | null
    source_id: string | null
    priority: 'low' | 'medium' | 'high'
    created_at: string
    updated_at: string
}

export type TodoSuggestion = {
    id: string
    text: string
    source_type: string
    source_id: string
    priority: 'high' | 'medium' | 'low'
    action?: string
}

// ========================================================
// CRUD Operations
// ========================================================

/**
 * Fetches all todos for the current user
 */
export async function getTodos(): Promise<Todo[]> {
    const supabase = await createClient()
    const { data: { user } } = await supabase.auth.getUser()

    if (!user) return []

    try {
        const { data, error } = await supabase
            .from('todos')
            .select('*')
            .eq('user_id', user.id)
            .order('completed', { ascending: true })
            .order('created_at', { ascending: false })

        if (error) {
            console.error('Error fetching todos:', error)
            return []
        }

        return data || []
    } catch (error) {
        console.error('Error fetching todos:', error)
        return []
    }
}

/**
 * Creates a new todo
 */
export async function createTodo(text: string): Promise<{ success: boolean; error?: string }> {
    const supabase = await createClient()
    const { data: { user } } = await supabase.auth.getUser()

    if (!user) {
        return { success: false, error: 'User not authenticated' }
    }

    if (!text || text.trim().length === 0) {
        return { success: false, error: 'Todo text cannot be empty' }
    }

    try {
        const { error } = await supabase
            .from('todos')
            .insert({
                user_id: user.id,
                text: text.trim(),
                completed: false,
                is_auto_generated: false,
                priority: 'medium'
            })

        if (error) {
            console.error('Error creating todo:', error)
            return { success: false, error: error.message }
        }

        revalidatePath('/dashboard')
        return { success: true }
    } catch (error) {
        console.error('Error creating todo:', error)
        return { success: false, error: 'Failed to create todo' }
    }
}

/**
 * Toggles a todo's completed status
 */
export async function toggleTodo(id: string, completed: boolean): Promise<{ success: boolean; error?: string }> {
    const supabase = await createClient()
    const { data: { user } } = await supabase.auth.getUser()

    if (!user) {
        return { success: false, error: 'User not authenticated' }
    }

    try {
        const { error } = await supabase
            .from('todos')
            .update({ completed })
            .eq('id', id)
            .eq('user_id', user.id)

        if (error) {
            console.error('Error toggling todo:', error)
            return { success: false, error: error.message }
        }

        revalidatePath('/dashboard')
        return { success: true }
    } catch (error) {
        console.error('Error toggling todo:', error)
        return { success: false, error: 'Failed to toggle todo' }
    }
}

/**
 * Deletes a todo
 */
export async function deleteTodo(id: string): Promise<{ success: boolean; error?: string }> {
    const supabase = await createClient()
    const { data: { user } } = await supabase.auth.getUser()

    if (!user) {
        return { success: false, error: 'User not authenticated' }
    }

    try {
        const { error } = await supabase
            .from('todos')
            .delete()
            .eq('id', id)
            .eq('user_id', user.id)

        if (error) {
            console.error('Error deleting todo:', error)
            return { success: false, error: error.message }
        }

        revalidatePath('/dashboard')
        return { success: true }
    } catch (error) {
        console.error('Error deleting todo:', error)
        return { success: false, error: 'Failed to delete todo' }
    }
}

/**
 * Generates smart todo suggestions based on business data
 */
export async function getAutoGeneratedTodos(): Promise<TodoSuggestion[]> {
    const supabase = await createClient()
    const { data: { user } } = await supabase.auth.getUser()

    if (!user) return []

    const suggestions: TodoSuggestion[] = []

    try {
        // 1. Check for pending orders that need shipping
        const { data: pendingOrders } = await supabase
            .from('orders')
            .select('id, customers(name)')
            .eq('user_id', user.id)
            .eq('status', 'pending')
            .limit(5)

        if (pendingOrders && pendingOrders.length > 0) {
            pendingOrders.forEach((order: any) => {
                suggestions.push({
                    id: `pending-${order.id}`,
                    text: `Ship order for ${order.customers?.name || 'customer'}`,
                    source_type: 'order',
                    source_id: order.id,
                    priority: 'high',
                    action: 'ship'
                })
            })
        }

        // 2. Check for processing orders needing updates
        const { data: processingOrders } = await supabase
            .from('orders')
            .select('id, customers(name)')
            .eq('user_id', user.id)
            .eq('status', 'processing')
            .limit(3)

        if (processingOrders && processingOrders.length > 0) {
            processingOrders.forEach((order: any) => {
                suggestions.push({
                    id: `processing-${order.id}`,
                    text: `Update order status for ${order.customers?.name || 'customer'}`,
                    source_type: 'order',
                    source_id: order.id,
                    priority: 'medium'
                })
            })
        }

        // 3. Check for low stock products
        const { data: lowStockProducts } = await supabase
            .from('products')
            .select('id, name, current_stock')
            .eq('user_id', user.id)
            .eq('stock_status', 'low_stock')
            .limit(3)

        if (lowStockProducts && lowStockProducts.length > 0) {
            lowStockProducts.forEach((product: any) => {
                suggestions.push({
                    id: `stock-${product.id}`,
                    text: `Restock ${product.name} (${product.current_stock || 0} left)`,
                    source_type: 'product',
                    source_id: product.id,
                    priority: 'high'
                })
            })
        }

        // 4. Check for recent orders to follow up (delivered 2-3 days ago)
        const threeDaysAgo = new Date()
        threeDaysAgo.setDate(threeDaysAgo.getDate() - 3)
        const twoDaysAgo = new Date()
        twoDaysAgo.setDate(twoDaysAgo.getDate() - 2)

        const { data: recentOrders } = await supabase
            .from('orders')
            .select('id, customers(name, phone)')
            .eq('user_id', user.id)
            .eq('status', 'delivered')
            .gte('updated_at', threeDaysAgo.toISOString())
            .lte('updated_at', twoDaysAgo.toISOString())
            .limit(2)

        if (recentOrders && recentOrders.length > 0) {
            recentOrders.forEach((order: any) => {
                suggestions.push({
                    id: `followup-${order.id}`,
                    text: `Follow up with ${order.customers?.name || 'customer'} on delivery`,
                    source_type: 'customer',
                    source_id: order.id,
                    priority: 'low'
                })
            })
        }

        // Sort by priority (high -> medium -> low)
        const priorityOrder = { high: 0, medium: 1, low: 2 }
        suggestions.sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority])

        return suggestions

    } catch (error) {
        console.error('Error generating todo suggestions:', error)
        return []
    }
}

/**
 * Creates a todo from a suggestion
 */
export async function createTodoFromSuggestion(
    text: string,
    sourceType: string,
    sourceId: string,
    priority: 'high' | 'medium' | 'low'
): Promise<{ success: boolean; error?: string }> {
    const supabase = await createClient()
    const { data: { user } } = await supabase.auth.getUser()

    if (!user) {
        return { success: false, error: 'User not authenticated' }
    }

    try {
        const { error } = await supabase
            .from('todos')
            .insert({
                user_id: user.id,
                text: text.trim(),
                completed: false,
                is_auto_generated: true,
                source_type: sourceType,
                source_id: sourceId,
                priority
            })

        if (error) {
            console.error('Error creating todo from suggestion:', error)
            return { success: false, error: error.message }
        }

        revalidatePath('/dashboard')
        return { success: true }
    } catch (error) {
        console.error('Error creating todo from suggestion:', error)
        return { success: false, error: 'Failed to create todo' }
    }
}
